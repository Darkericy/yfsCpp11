# yfsCpp11
yfs是一个分布式文件系统

![](https://img-blog.csdnimg.cn/20190222184912911.jpg)
`yfs`可以看作是客户端，客户端首先要从的`lock server`中获得锁，之后才能与共享的`extent server`(实际存储数据的服务器)通信，
这种架构能有利于提高添加客户端的效率。

## lab1-lab7小结
### lab1：实现锁服务器
#### Q&A
1. 锁服务器有什么用？
yfs是一个分布式文件系统，客户端通过网络与服务器通信，那要怎么保证两个客户不会修改同一个文件，
这就需要一个防止资源竞争的机制，即加锁。

在lab1中，我们可以假设每一个时刻只有一个客户，所以暂时不用考虑当一个客户申请的锁是空闲或被别的客户占用的情况。
在后续的实验会继续完善。

2. 怎么获得锁？
使用RPC，客户远程调用锁服务器的锁请求RPC handler。

3. 怎么实现RPC的最多执行一次语义？
这是lab1第二部分的重点，只要记录哪个客户持有了那个锁，哪个客户还在等待锁。

### lab2&lab3：实现基本的文件服务
#### Q&A
1. fuse是什么？
[资料](https://blog.csdn.net/ty_laurel/article/details/51685193)

2. extent_server又是什么？
实际存储数据的服务器，只有一个，所有yfs客户端都与它通信，实现共享的文件系统。

### lab4&lab5：锁缓存
#### Q&A
1. 为什么需要锁缓存？
假设一种情形：一个客户需要创建100个文件，那么根据之前的设计就需要发送100次RPC请求锁到锁服务器，
这明显是不科学的。

2. 锁缓存怎么缓存？
这就需要设计好客户端与锁服务器之间的协议，也是这次实验的难点。

例如：客户A需要创建100个文件，这时它需要发送一个RPC到锁服务器，假如锁是空闲的，
客户A获得锁，如果它创建完一个文件不需要将锁还给锁服务器，它可以继续创建文件。
但这个时候，客户B向锁服务器发送锁请求RPC，由于锁不是空闲的，它发送重试RPC给客户B，
服务器根据记录查到锁在客户A那里，它就发送释放RPC给客户A，客户A释放锁，
服务器就发送唤醒RPC给客户B，现在客户B就能获得锁了。


### lab6&lab7：Paxos与RSM
#### Q&A
1. 为什么需要Paxos和RSM？
既然是分布式文件系统，那么可定就需要多个服务器，这样就增大了服务器的可用性与容错性。

多个服务器肯定就需要一种机制来保证每个服务器都是“一样”的，要让客户觉得它们就是一个服务器。

而Paxos就是一种分布式一致性算法，而RSM是复制状态机，Paxos作为RSM的底层结构。

